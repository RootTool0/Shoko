<div align="center">
  <h1>Shoko - Compile-time UI Framework</h1>
</div>

<p align="center">
  <img src="ReadMeAssets/1.png" style="width:300px;">
</div>

<div align="center">
  <h2>«С помощью этого блокнота мы сможем общаться. Давайте будем друзьями»
  <br><br>
  Экспериментальный UI-фреймворк на C++17, где интерфейс строится и валидируется во время компиляции</h2>
</div>

<div align="center">
<p>
  <a href="#что-это">Что это?</a> •
  <a href="#особенности">Особенности</a> •
  <a href="#философия">Философия</a> •
  <a href="#пример">Пример</a> •
  <a href="#обратная-связь">Обратная связь</a>
</p>
</div>

## Что это?

**Shoko** - это экспериментальный **compile-time UI-фреймворк на C++17**, в котором пользовательский интерфейс **полностью описывается, проверяется и собирается во время компиляции**.

Здесь UI - не данные и не runtime-дерево, а типовая структура, выраженная через `constexpr`, шаблоны и fluent-интерфейс.
Ошибки компоновки, несовместимые виджеты, некорректные параметры - всё это выявляется до запуска программы.

**Shoko** - это попытка ответить на вопрос:

> Как далеко можно зайти, перенося Runtime в Compile-time?

## Особенности
- **Compile-time описание и сборка структуры UI**
  Иерархия виджетов формируется и проверяется во время компиляции.
- **Статическая валидация композиции:**
  - Корректность типов виджетов
  - Допустимость вложенности
  - Наличие обязательных свойств
  - Корректные сигнатуры событий
- **Fluent API в стиле Slate:**
```cpp
SNew<SButton>()
.SetPosition(...)
.SetSize(...)
.OnHover(...)
```
- **Минимизация runtime-аллоцирований**
  Структура UI известна заранее и не требует создания в куче.
- **Runtime отвечает только за исполнение**
  Ввод, события, состояние и отрисовка остаются runtime-задачами.

## Философия

<img src="ReadMeAssets/5.png" width="190px" align="left" hspace="25">

### «С помощью этого блокнота мы сможем общаться»

**Shoko** - это не просто UI-фреймворк. Это диалог:

Диалог между разработчиком и компилятором, где пользовательский интерфейс становится не набором инструкций для выполнения, а **описанием того, что должно быть**. Раз и навсегда

<br clear="left">

---

### Ограничение как свобода

В мире, где ценят бесконечную гибкость и динамичность, **Shoko** предлагает иной путь: **статика как преимущество**

Как **Шоко Нишимия**, персонаж, вдохновивший этот проект, общается через блокнот - медленно, обдуманно, без возможности взять слова назад - так и наш фреймворк "говорит" с миром через этап компиляции. Каждый виджет, каждая связь, каждая формула - проверяются до запуска программы. Если диалог логичен - программа соберётся. Если нет - вы узнаете об этом сразу, а не через час тестирования

---

<img src="ReadMeAssets/6.png" width="265px" align="right" hspace="25">

### Нулевые компромиссы

**Shoko** родилась из **embedded-мира**, где каждый байт памяти и каждый такт процессора на счету. Поэтому она не спрашивает: "Как добавить ещё одну фичу?" Она спрашивает: "Как сделать то же самое, но без дополнительных расходов?"
- **Без виртуальных таблиц** - статическая диспетчеризация через CRTP
- **Без динамических аллокаций** - вся память известна при компиляции
- **Без runtime проверок** - всё валидируется до запуска
- **Без скрытых costs** - вы платите только за то, что видите

<br clear="rigth">

---

<!-- <img src="ReadMeAssets/7.png" width="265px" align="left" hspace="25"> -->

### «Давайте будем друзьями»

Ошибки компиляции - не провал, а продолжение диалога. Shoko не кричит `static_assert failed`. Она вежливо объясняет:

```
[Shoko]
Кажется, вы пытаетесь создать виджет, о котором я не знаю...
Скорее всего, он просто не унаследован от базового класса SWidget.
Может, расскажете мне, что это за виджет?
```

Потому что **код - в первую очередь для людей. И только потом для машин**

<!-- <br clear="left"> -->

---

### UI как константа, а не процесс

В традиционных фреймворках UI "создаётся" при запуске. А что если... Он уже существует? В Shoko **UI уже существует** в момент загрузки программы - как часть секции `.rodata` в бинарнике, как константная структура данных, которая просто ждёт, чтобы её отрисовали

Ваш интерфейс инициализируется раньше, чем начинает выполняться `main()`. И это меняет всё

---

### Для кого это?

Shoko не пытается быть фреймворком для всего. Она идеальна для:

- **Embedded-систем**, где предсказуемость важнее гибкости
- **Safety-critical приложений**, где ошибка в UI = перепрошивка устройства
- **Инструментов разработки**, где интерфейс статичен и известен заранее
- **Исследователей**, интересующихся границами compile-time вычислений

И бесполезна для:
- Динамических конструкторов интерфейсов
- Систем с плагинами, добавляющими UI элементы
- Случаев, где структура UI полностью определяется в рантайме

И это нормально. Потому что **инструмент не должен быть для всего**. Он должен быть идеальным для своей области

---

### Что с именем?

**Shoko** - не просто "крутое анимешное название". Это метафора

Как **Шоко Нишимия** преодолела свою немоту через блокнот, так и этот фреймворк преодолевает хаос runtime через compile-time

**Ограничение рождает красоту. Статика рождает надёжность**

---

<img src="ReadMeAssets/3.png" width="230px" align="right" hspace="25">

### Завершение

**Shoko** - это приглашение к другому способу мышления. К диалогу с компилятором. К уважению ресурсов. К красоте простых решений сложных проблем

Она ещё сырая. Она ещё эксперимент. Но в каждой её строчке - вопрос: "А что, если UI может быть таким же статичным, как алгоритм сортировки?"

И пока компилятор отвечает "да" - мы будем продолжать этот диалог

<br clear="rigth">

## Пример
```cpp
constexpr auto RootWidget = SNew<SWidgetContainer>
(
    SNew<SButton>()
        .SetPosition(100, 200)
        .SetSize(200, 200)
        .OnHover(&TestOnHover1)
        .OnUnhover(&TestOnUnhover1)
        .SetColor(FColor(255, 50, 50)),
        
    SNew<SButton>()
        .SetPosition(400, 200)
        .SetSize(200, 200)
        .OnHover(&TestOnHover2)
        .OnUnhover(&TestOnUnhover2)
        .SetColor(FColor(50, 50, 255)),

    SNew<SBoxWidget>()
        .SetPosition(300, 200)
        .SetSize(100, 100)
        .SetColor(FColor(255, 255, 255))
);
```
**В этом примере:**
- Структура UI полностью известна компилятору
- Ошибки композиции выявляются при компиляции
- Runtime не участвует в создании дерева

## Обратная связь

<img src="ReadMeAssets/4.png" width="200px" align="left" hspace="25">

Если у вас есть вопросы, предложения или баги, то можете связаться со мной:

- **Telegram (канал/блог)**: [RootTool Blog](https://t.me/RootToolBlog)
- **Telegram (ЛС)**: [@RootTool28](https://t.me/RootTool28)
- **Discord**: `.roottool` (или `RootTool#5776`)
- **YouTube**: [RootTool](https://www.youtube.com/@RTEdits0)

_(прошу не беспокоить меня без причины)_

<br>
